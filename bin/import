#!/usr/bin/env node

let command = require('commander'),
    fs = require('fs'),
    db = require('../db'),
    Project = require('../db/models/Project'),
    ObjectId = require('mongodb').ObjectId,
    request = require('request-promise-native'),
    chalk = require('chalk'),
    handleError = (err) => {
        console.error(err);
        process.exit(1);
    },
    chunkSize = 5; // five at a time

command.version('0.0.0')
    .option('-r --root <root>','The sciencebase folder id to import items from.')
    .parse(process.argv);

command.browseType = command.browseType||'Project';
if(!command.root) {
    command.help();
}

let counts = {
    start: (new Date()).getTime(),
    page: 0,
    total: 0,
    found: 0,
    imported: 0
};

function importOnePage(response) {
    console.log(`-- processing page # ${counts.page++}`);
    response = JSON.parse(response);
    let next = () => {
            if(response.nextlink && response.nextlink.url) {
                request(response.nextlink.url).then(importOnePage).catch(handleError);
            } else {
                let time = ((new Date()).getTime() - counts.start)/1000;
                console.log(chalk.green(`\n\nComplete: total: ${counts.total}, found: ${counts.found}, imports: ${counts.imported} time: ${time} seconds`));
                process.exit(0);
            }
        },
        items = response.items;
        toInsert = items.map(i => {
            return {
                _id: i.id,
                title: i.title,
                mdJson: i.files ? i.files.reduce((found,f) => {
                        return found||(f.name === 'md_metadata.json' ? f.url : undefined);
                    },undefined) : undefined
            }
        }).filter(i => {
            if(!i.mdJson) {
                console.warn(chalk.red(`\tWARNING: item with title "${i.title}" does not have attached mdJson`));
            }
            return i.mdJson
        });
    counts.total += items.length;
    counts.found += toInsert.length;
    if(toInsert.length) {
        // fetch and fill in mdJson
        Promise.all(toInsert.map(i => {
            return new Promise((resolve,reject) => {
                request(i.mdJson).then(mdj => resolve(JSON.parse(mdj))).catch(handleError);
            });
        }))
        .then(jsons => {
            // insert into the db
            Promise.all(jsons.map((o,i) => {
                let insert = toInsert[i];
                insert.mdJson = o;
                insert._id = new ObjectId(insert._id);
                console.log(`\timporting "${insert.title}"`);
                // create new, requires they don't already exist in the db
                //return (new Project(toInsert[i])).save();
                // upsert, for repeat crawls
                return new Project((resolve,reject) => {
                    Project.findOneAndUpdate({
                        _id: insert._id
                    },insert,{upsert:true},(err,o) => {
                        if(err){
                            handleError(err);
                        }
                        resolve(o);
                    });
                });
            }))
            .then(inserted => {
                counts.imported += inserted.length;
                next();
            }).catch(handleError);
        })
        .catch(handleError); // can't happen but...
    } else {
        next();
    }
}

function bootstrap() {
    request({
            url: `https://www.sciencebase.gov/catalog/items`,
            qs: {
                fields: 'title,files',
                filter0: `browseCategory=Project`,
                filter1: 'tags=LCC Network Science Catalog',
                filter2: `ancestors=${command.root}`,
                sort: 'lastUpdated',
                order: 'desc',
                format: 'json',
                max: chunkSize
            }
        })
        .then(importOnePage)
        .catch(handleError);
}
db().then(bootstrap).catch(handleError);
