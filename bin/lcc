#!/usr/bin/env node

let command = require('commander'),
    db = require('../dist/db').db,
    Lcc = require('../dist/db/models/Lcc').Lcc,
    Item = require('../dist/db/models/Item').Item,
    request = require('request-promise-native'),
    ObjectId = require('mongodb').ObjectId,
    handleError = (err) => {
        console.error(err);
        process.exit(1);
    };

process.on('uncaughtException', handleError);

command.version('1.0.0')
    .option('--lcc <id>', 'The lcc to add or remove.')
    .option('--action <action>', 'What to do with the LCC (add, remove, list or available. default add)', /^(add|remove|list|available)$/i, 'add')
    .parse(process.argv);

if(command.action !== 'list' && command.action !== 'available' && !command.lcc) {
    command.help();
}

function add(id) {
    return new Promise((resolve) => {
        request({
            url: `https://www.sciencebase.gov/catalog/item/${id}`,
            qs: {
                format: 'json',
                fields: 'title'
            }
        })
        .then(json => {
            let data = JSON.parse(json),
                lcc = {
                    _id: new ObjectId(data.id),
                    title: data.title,
                };
            Lcc.findOneAndUpdate({ _id: lcc._id},lcc,{upsert: true, new: true},(err,o) => {
                if(err) {
                    handleError(err);
                }
                resolve(o);
            });
        })
        .catch(handleError);
    });
}

function remove(id) {
    return new Promise((resolve) => {
        // using find and then remve (rather than findOneAndRemove) so schema
        // hooks are executed (to clean up Items).
        Lcc.findById(id,(err,lcc) => {
            if(err) {
                handleError(err);
            }
            if(!lcc) {
                return resolve(null);
            }
            lcc.remove((err,lcc) => {
                if(err) {
                    handleError(err);
                }
                resolve(lcc);
            });
        });
    });
}

function getAllIds() {
    return new Promise((resolve,reject) => {
        request({
            url: 'https://lccnetwork.org/api/v1/lcc?$select=title,sbid',
            qs: {
                $select: 'title,sbid',
            }
        })
        .then(response => resolve(JSON.parse(response).list))
        .catch(reject);
    });
}

db().then(() => {
    let promises,logMsg;
    switch(command.action) {
        case 'add':
            logMsg = 'added';
            promises = command.lcc.split(',').map(id => add(id));
            break;
        case 'remove':
            logMsg = 'removed';
            promises = command.lcc.split(',').map(id => remove(id));
            break;
        case 'list':
            Lcc.find({},(err,lccs) => {
                if(err) {
                    handleError(err);
                }
                lccs.forEach(lcc => console.log(`[${lcc._id}] "${lcc.title}"`+(lcc.lastSync ? ` lastSync:${lcc.lastSync}` : '')));
                process.exit(0);
            });
            break;
        case 'available':
            getAllIds()
            .then(list => {
                list.forEach(lcc => console.log(`${lcc.sbid} : ${lcc.title}`));
                let ids = list.map(lcc => lcc.sbid).join(',');
                console.log(ids);
                process.exit(0);
            })
            .catch(handleError);
            break;
    }
    if(promises) {
        Promise.all(promises)
            .then((results) => {
                results.filter(lcc => !!lcc)
                    .forEach(lcc => console.log(`${logMsg} [${lcc._id}] "${lcc.title}"`));
                process.exit(0);
            }).catch(handleError);
    }
}).catch(handleError);
